<!DOCTYPE html>
<html lang="pl">
<head prefix="og: http://ogp.me/ns#">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=Edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link rel="manifest" href="/manifest.json">
<title>PNŚ2: Jak poprawić bezpieczeństwo strony jednym meta-tagiem - Content-Security-Policy - skrypt</title>
<meta name="description" content="Jeśli tworzysz strony lub aplikacje webowe, Content-Security-Policy pozwoli Ci jedną linijką konfiguracji znacznie poprawić ich bezpieczeństwo." />
<!--[if IE 8]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/ie8/0.6.0/ie8.js"></script>
<![endif]-->
<link rel="index" href="https://zakasanerekawy.taurit.pl/">

<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
<link rel="icon" href="/favicon.ico" type="image/x-icon">

<!-- styles to allow render most useful content quickly, and load the rest of styles asynchronously -->
<!-- especially on slow mobile connections it should give some indication that the content WILL load -->
<style type="text/css">
    nav.navbar,#intro-header,div.media-left,hr,div.sidebar,.hidden,.hidden-overridable{display:none;}.outline-header{position:absolute;clip:rect(1px 1px 1px 1px);clip:rect(1px,1px,1px,1px);padding:0;border:0;height:1px;width:1px;overflow:hidden;}
    </style>
<link href="/assets/css/bundle.min.css?v=1cc8c" rel="stylesheet" />

<meta name="application-name" content="Zakasane rękawy" />
<meta name="apple-mobile-web-app-title" content="Zakasane rękawy">
<meta name="msapplication-tooltip" content="Zakasane rękawy" />
<meta name="msapplication-starturl" content="/" />
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="msapplication-navbutton-color" content="#558eaf">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#558eaf"> 


<meta name="twitter:card" content="summary" />
<meta name="twitter:url" content="https://zakasanerekawy.taurit.pl/podcast/programowanie-na-sniadanie/2/script" />
<meta name="twitter:title" content="Podcast" />
<meta name="twitter:description" content="Jeśli tworzysz strony lub aplikacje webowe, Content-Security-Policy pozwoli Ci jedną linijką konfiguracji znacznie poprawić ich bezpieczeństwo." />
<meta name="twitter:image" content="https://zakasanerekawy.taurit.pl/assets/img/icon.png" />

<meta property="fb:app_id" content="1768845453415639" /> 
<meta property="og:title" content="PNŚ2: Jak poprawić bezpieczeństwo strony jednym meta-tagiem - Content-Security-Policy - skrypt" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zakasanerekawy.taurit.pl/podcast/programowanie-na-sniadanie/2/script" />
<meta property="og:description" content="Jeśli tworzysz strony lub aplikacje webowe, Content-Security-Policy pozwoli Ci jedną linijką konfiguracji znacznie poprawić ich bezpieczeństwo." />


        <meta property="og:image" content="https://zakasanerekawy.taurit.pl/assets/img/podcast/programowanie-na-sniadanie/podcast-banner-image-1200x627.jpg" />
        <meta property="og:image:alt" content="https://zakasanerekawy.taurit.pl/assets/img/podcast/programowanie-na-sniadanie/podcast-banner-image-1200x627.jpg" />
        <meta property="og:image:width" content="1200" />
        <meta property="og:image:height" content="627" />




<link rel="canonical" href="https://zakasanerekawy.taurit.pl/podcast/programowanie-na-sniadanie/2/script"> 
<meta name="robots" content="noindex" />


    <link type="application/rss+xml" rel="alternate" title='Programowanie na śniadanie' href="/podcast/programowanie-na-sniadanie/feed.rss" />

<link rel="icon" type="image/png" sizes="512x512" href="/assets/img/icon-512x512.png">
<link rel="icon" type="image/png" sizes="128x128" href="/assets/img/icon-128x128.png">
<link rel="icon" type="image/png" sizes="96x96" href="/assets/img/icon-96x96.png">
<link rel="icon" type="image/png" sizes="72x72" href="/assets/img/icon-72x72.png">
<link rel="icon" type="image/png" sizes="64x64" href="/assets/img/icon-64x64.png">
<link rel="apple-touch-icon" type="image/png" sizes="512x512" href="/assets/img/icon-512x512.png">

<!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.7/es5-shim.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.7/es5-sham.min.js"></script>
<![endif]-->

</head>
<body>
<a class="skip-to-main-content" href="#content">Przejdź do treści</a> 
<h1 class="outline-header">Blog &ldquo;Zakasane rękawy&rdquo;</h1>

<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <h1 class="outline-header">Menu główne</h1>

        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" id="navbar-button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" rel="home" href="/" tabindex="-1">Zakasane rękawy</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="navbar-collapse">
            <ul class="nav navbar-nav navbar-right">
                    <li><a href="/" rel="home">Start</a></li>
    <li><a href="/posts/" rel="toc">Spis treści</a></li>
    <li><a href="/podcast/programowanie-na-sniadanie/">Podcast</a></li>
    <li><a href="/about">O blogu</a></li>

            </ul>
        </div>
    </div>
</nav>



<!-- Page Header -->
<header class="intro-header header-podcast" id="intro-header">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
<div class="site-heading">
    <h1>Podcast</h1>
        <h2>Audycje » <a href='/podcast/programowanie-na-sniadanie/'>Programowanie na śniadanie</a> » <a href='/podcast/programowanie-na-sniadanie/2'>Odcinek #2</a> » <a href='/podcast/programowanie-na-sniadanie/2/script'>Skrypt</a></h2>
</div>                </div>
        </div>
    </div>
</header>

<!-- Main Content -->
<div class="container">
    <div class="row">
        <div id="content" class="col-md-12">
            

<h2>PNŚ #2. Jak poprawić bezpieczeństwo strony jednym meta-tagiem - Content-Security-Policy</h2>
<div id="fb-root"></div>
<div class="podcast-subscription-form">
    <!-- Begin MailChimp Signup Form -->
    <div id="mc_embed_signup">
        <form action="https://taurit.us16.list-manage.com/subscribe/post?u=330f3c8a4e6aab69c57478e23&amp;id=0bdc5f15d2"
            method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form"
            class="validate form form-inline" target="_blank" novalidate>
            <p class="subscription-form-header">Otrzymaj powiadomienie o nowych odcinkach</p>
            <input type="email" value="" name="EMAIL" class="required email form-control" id="mce-EMAIL"
                placeholder="Twój adres email">
            <input type="text" value="" name="FNAME" class="form-control" id="mce-FNAME" placeholder="Twoje imię">
            <input type="submit" value="Zapisz" name="subscribe" id="mc-embedded-subscribe"
                class="btn btn-success btn-normal">

            <div id="mce-responses">
                <div class="response" id="mce-error-response" style="display:none"></div>
                <div class="response" id="mce-success-response" style="display:none"></div>
            </div>

            <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
            <div style="position: absolute; left: -5000px;" aria-hidden="true">
                <input type="text" name="b_330f3c8a4e6aab69c57478e23_0bdc5f15d2" tabindex="-1" value="">
            </div>
        </form>
    </div>
    <!--End mc_embed_signup-->
</div>
<p>To jest podcast "Programowanie na śniadanie". Słuchasz odcinka numer 2. Dziś opowiem o mechanizmie
    <em>Content-Security-Policy</em>, który pozwala programistom aplikacji webowych takim jak my, poprawić
    bezpieczeństwo strony przy pomocy praktycznie jednej linijki konfiguracji.</p>

<p class="podcast-transcript-jingle">intro</p>

<h2>Dla kogo jest ten odcinek?</h2>

<p>Cześć! Z tej strony Paweł, bardzo się cieszę że zechciałeś lub zechciałaś zajrzeć do tego odcinka podcastu. Na samym
    starcie chcę przekazać Ci w skrócie o czym będzie, żeby pozwolić Ci ocenić czy warto poświęcić na niego najbliższe
    kilkanaście minut. Po tym wstępie będzie jingiel i przejdziemy do konkretów i mam nadzieję, że zechcesz zostać do
    samego końca ;)</p>

<p>W tej audycji opowiem o mechanizmie <em>Content-Security-Policy</em>, który jest związany z bezpieczeństwem aplikacji
    webowych i stron internetowych, czyli generalnie wszystkiego co tworzymy na przeglądarki internetowe. Jeśli więc
    interesuje Cię web development, a do tej pory nie spotkałeś albo nie spotkałaś się z tym mechanizmem, albo już nie
    pamiętasz dokładnie do czego służy, to zachęcam, żeby poświęcić kilka minut na przypomnienie sobie tego tematu.</p>

<p>Ten mechanizm to tak naprawdę jedna linijka konfigurująca bezpieczeństwo naszej aplikacji i ta konfiguracja może
    siedzieć jako zwykły meta-tag w sekcji &lt;head&gt; strony, albo być przesyłana przez serwer jako nagłówek HTTP.</p>

<p>Postaram się tu prowadzić narrację tak, żeby nie zgubić Twojej uwagi mimo że odcinek może wymagać trochę skupienia i
    przede wszystkim pokazać pewne problemy z platformą Web, które dziś mamy i które próbujemy rozwiązywać mechanizmami
    takimi jak właśnie <em>Content-Security-Policy</em>. Będzie też wniosek bardzo pragmatyczny, a mianowicie taki że w
    nowo stawianych projektach web warto odejść od domyślnego zachowania przeglądarki i określić taką politykę
    bezpieczeństwa aplikacji, co nałoży na nas trochę restrykcji przy programowaniu, ale w rezultacie pozwoli stworzyć
    bezpieczniejszą aplikację.</p>

<p>Żeby pokazać faktyczne korzyści dla bezpieczeństwa, w trakcie tego odcinka przedstawię m.in. trzy przykładowe klasy
    ataków, którym pozwala zapobiec Content-Security-Policy: atak <em>Cross Site Scripting</em>, <em>Cross-Site
        Styling</em> i <em>Clickjacking</em> i postaram się przystępnie wyjaśnić na czym polegają.</p>

<p>Mam nadzieję, że zachęciłem Cię do słuchania i zapraszam :)</p>

<p class="podcast-transcript-jingle">jingiel</p>

<h2>Wstęp: dlaczego pozostając przy opcji domyślnej NIE jesteśmy bezpieczni</h2>

<p>Przyznam, że jako użytkownik do niedawna postrzegałem aplikacje w przeglądarkach jako wyjątkowo bezpieczne w
    porównaniu z tymi tradycyjnie instalowanymi na naszych maszynach. Programistyczna intuicja może nam wszystkim dawać
    takie wrażenie, bo w końcu używamy nowoczesnych przeglądarek, które działają w różnego rodzaju sandboxach, od
    jakiegoś czasu nie mają już Flasha ani Javy, a jedynie JavaScript który nie daje bezpośredniego dostępu do naszego
    dysku ani innych uprawnień które by pozwoliły przejąć kontrolę nad naszym laptopem czy innym urządzeniem.</p>

<p>Platforma webowa jest też w centrum uwagi dużych firm technologicznych takich jak Google czy Microsoft i na co dzień
    widać jak dawne niedogodności i problemy są łatane. My jako programiści piszący aplikacje, możemy dziś załatwić
    jedną linią kodu CSS lub JavaScript coś, co kilka lat temu wymagało dziesiątek albo setek linijek. Hacki, jakie
    kilka lat temu za czasów Internet Explorera 8 trzeba było wdrożyć, żeby zgodnie z modą dodać zaokrąglone rogi do
    przycisku wydają się niedorzeczne dzisiaj, kiedy walczy się raczej o osiągnięcie większej liczby klatek na sekundę w
    animacjach.</p>

<p>Przy całym tym postępie w świecie aplikacji internetowych zdarzają się jednak sytuacje, kiedy przypominamy sobie że
    pierwszy standard HTML został opublikowany daawno temu, w 1993 roku
    <reference url="https://www.w3.org/wiki/HTML/Specifications" />, i to dziedzictwo czasem do nas wraca w postaci
    różnorakich problemów. Możemy spojrzeć na platformę web jak na system, który działa produkcyjnie od ponad 25 lat.
    Ewoluując nie może sobie za bardzo pozwolić na zmiany, które nie byłyby kompatybilne wstecz, bo zepsułoby to masę
    istniejących stron i aplikacji.</p>

<p>Jednym z aspektów, które obrywają przez konieczność zachowania kompatybilności wstecz jest bezpieczeństwo.
    Przykładowo, w praktyce dopiero teraz na naszych oczach dokonuje się zmiana, w której protokół HTTP jest wypierany
    przez HTTPS. Ten brak szyfrowania, który do niedawna był typowy dla stron internetowych, to jeden z przykładów
    sytuacji, gdzie nie trzeba szczególnych zdolności hackerskich aby naruszyć prywatność użytkowników stron.</p>

<p>Bezpieczeństwo stron internetowych jest ważne przede wszystkim dlatego, że nasza przeglądarka pomimo tego że chroni
    nas dziś dość dobrze przed instalacją malware'u na maszynie na której działa, sama może stać się celem ataku innego
    rodzaju. Jako użytkownicy jesteśmy na ogół zalogowani w co najmniej kilku serwisach z których korzystamy i często
    dla wygody nie wylogowujemy się z nich tylko po prostu zamykamy zakładkę, pozostawiając sesję logowania aktywną.
    Jeśli odejdziemy od komputera i ktoś inny w tym czasie otworzy naszą przeglądarkę, to prawdopodobnie bez problemu
    wejdzie na naszego Twittera, LinkedIna, czy nasz program do zarządzania listą Todo i będzie mógł wykonać akcję w
    naszym imieniu.</p>

<p>W praktyce w naszym otoczeniu mamy raczej zaufane osoby i problemem nie jest taki lokalny atak bezpośrednio na nas,
    ale raczej na strony z których korzystamy. Patrząc z perspektywy web developera to mogą być ataki na strony które
    tworzymy i za których zabezpieczenie jesteśmy odpowiedzialni, dlatego warto przyjrzeć się niektórym z nich. W
    następnej części, która już za moment, opiszę krótko trzy rodzaje stosunkowo łatwych do zrozumienia i dość łatwych
    do wykonania ataków na strony czy aplikacje internetowe, a mianowicie:</p>

<ul>
    <li><em>Cross Site Scripting</em> (XSS)</li>
    <li><em>Cross-Site Styling</em>, czyli atak na style strony które intuicyjnie mogą wydawać się zupełnie bezpieczną
        częścią strony</li>
    <li><em>Clickjacking</em></li>
</ul>

<p>Po tej nadchodzącej sekcji i przedstawieniu problemów przejdę natomiast do rozwiązań, czyli tego jak możemy zapobiec
    skutkom ataków definiując politykę bezpieczeństwa dla strony przez tytułowy mechanizm
    <em>Content-Security-Policy</em>.</p>

<p class="podcast-transcript-jingle">jingiel</p>

<h2>Przykładowe ataki klasy code-injection</h2>

<h3>Cross Site Scripting</h3>

<p>Zacznę od przedstawienia tego czym jest podatność strony na Cross-Site-Scripting. Cross Site Scripting, często
    oznaczany akronimem XSS, to rodzaj łatwego do popełnienia błędu w aplikacji pisanej na przeglądarki. Ten błąd
    pozwala osobie o złych zamiarach na dodanie do naszej aplikacji internetowej dodatkowego kodu JavaScript, który
    wykona się u osoby odwiedzającej stronę w przeglądarce.</p>

<p>Ten błąd jest podobny w naturze do wielu innych błędów które można sklasyfikować jako code-injection, czyli błędów
    pozwalających na wstrzykiwanie kodu. Najogólniej ujmując błąd typu code-injection pojawia się, kiedy aplikacja
    wysyła jakieś niezaufane dane, czyli np. takie wprowadzone przez użytkownika, do interpretera. Chyba
    najpopularniejszym błędem tej klasy jest SQL Injection, ale w przypadku Cross-Site-Scripting interpreterem nie jest
    silnik bazy danych, ale silnik JavaScript w przeglądarce.</p>

<p>Błąd typu Cross Site Scripting możemy popełnić pisząc już swoją pierwszą aplikację typu "hello world". Przypuśćmy, że
    w tej prostej aplikacji pytamy użytkownika o imię, które może wpisać w polu tekstowym na stronie, a kiedy je poda i
    wciśnie przycisk to wyświetlamy tekst typu "Witaj, [imię]" przez JavaScriptową metodę document.write(). W tej
    sytuacji dajemy użytkownikowi możliwość nadużycia, bo jeśli zamiast swojego imienia wprowadzi tag &lt;script&gt;
    a w środku fragment kodu JavaScript, to ten kod zostanie dodany do strony i wykonany w przeglądarce tego
    użytkownika.</p>

<p>Przypuśćmy teraz, że jako programiści zrobimy podobny błąd pisząc system komentarzy np. w sklepie internetowym. Jeśli
    pozwolimy użytkownikom podczas dodawania komentarza w polu "imię" dokleić skrypt i zachowamy potem takiego stringa w
    bazie danych żeby go wyświetlać przy komentarzu, to ten może wykonać się u wszystkich użytkowników oglądających ten
    komentarz i to w kontekście ich sesji. A więc doklejony skrypt będzie miał dostęp do tych samych danych strony, co
    użytkownik, przypuszczalnie np. numeru karty kredytowej zapisanego w opcjach sklepu internetowego, i będzie mógł
    wysłać te dane na serwer atakującego.</p>

<p>Mechanizm Content-Security Policy może pomóc rozwiązać ten problem, bo pozwala nam poinstruować przeglądarkę, żeby
    nie wykonywała żadnego kodu JavaScript zagnieżdżonego w kodzie HTML. Dokument HTML jest typowo dynamicznie
    generowany w czasie wykonania programu przez aplikację i mocno narażony na błędy programisty. Jedną dyrektywą CSP
    możemy więc ustalić, że żadne skrypty zdefiniowane w blokach &lt;script&gt; ani w atrybutach elementów HTML takich
    jak <code>onclick</code> nie będą po prostu wykonywane przez przeglądarkę. W typowym przypadku zechcemy przy tym
    zachować możliwość wykonywania skryptów które są załączane jako pliki zewnętrzne, ale dla nich możemy również
    zdefiniować listę domen które są zaufane, na zasadzie whitelisty. Nałożenie takich restrykcji znacznie ogranicza w
    praktyce możliwość wykonania ataku Cross Site Scripting, bo kod z powodzeniem wstrzyknięty razem z legalnymi danymi
    w markup strony po prostu się nie wykona.</p>

<p class="podcast-transcript-jingle">jingiel</p>

<h3>Cross Site Styling</h3>

<p>Przed chwilą opisałem na czym polega atak Cross Site Scripting i dlaczego w związku z nim dobrze jest zablokować
    wykonywanie w aplikacji webowej wszystkich skryptów zagnieżdżonych. Można sobie zadać pytanie, czy innego rodzaju
    zasoby takie jak np. style CSS lub zewnętrzne czcionki lub obiekty audio i video również powinny być blokowane i czy
    potencjalny atakujący jest w stanie w jakiś sposób skorzystać np. z wstrzyknięcia do kodu strony dodatkowych styli
    CSS.</p>

<p>W przypadku wstrzyknięcia na stronę złośliwych styli problemem jest to, że strona może zmienić swój wygląd w sposób
    który będzie mniej lub bardziej niebezpieczny dla użytkownika. CSS pozwala dziś transformować wygląd strony w bardzo
    dużym stopniu. Można sobie wyobrazić sytuację, gdzie np. link dodany w komentarzu przez użytkownika jest przez
    wstrzyknięte style przeniesiony wizualnie gdzieś na górę strony do głównego menu z nawigacją, i w ten sposób
    atakującemu uda się przekierować część naszych użytkowników na własną podrobioną witrynę. Poprzez CSS można też
    dodać tekst gdzieś na stronie, który może chociażby ośmieszyć serwis albo obrazić jakąś grupę odbiorców. Przy udanym
    ataku można też załączyć do strony jednopikselowy obrazek umieszczony w domenie atakującego. Wtedy przeglądarki
    użytkowników wchodzących na stronę będą wysyłać do tego złośliwego serwera żądanie, co pozwoli atakującemu poznać
    np. poziom ruchu na stronie i adresy IP wszystkich odwiedzających.</p>

<p>Ogólnie rzecz biorąc style pozwalają na złośliwości mniejszego kalibru niż opisywany wcześniej Cross Site Scripting.
    Natomiast jeśli stawiamy projekt od zera, to warto rozważyć zablokowanie wykonywania wszystkich styli znajdujących
    się wewnątrz tagu <code>style</code> na stronie i w atrybutach <code>style</code> tagów HTML i mieć ten potencjalny
    problem z głowy, pozwalając jedynie na ładowanie arkuszy styli z zewnętrznych plików. Unikanie styli w atrybutach
    było chyba zresztą od zawsze dobrą praktyką jeśli chodzi o utrzymanie separacji kodu, ułatwienie cache'owania, oraz
    ze względu na dużą tzw. specyficzność selektorów CSS definiowanych w atrybutach, z którą każdy kto miał do czynienia
    z CSS kiedyś walczył.</p>

<p>W konfiguracji Content-Security-Policy możemy jedną dyrektywą zablokować wykonywanie styli zagnieżdżonych, oraz
    określić domeny internetowe z których ładowanie zewnętrznych arkuszy styli jest dozwolone. O tym czym jest dyrektywa
    powiem jeszcze za chwilę, ale najpierw jeszcze dwa słowa o innej potencjalnej luce bezpieczeństwa którą możemy
    zablokować na poziomie aplikacji, a mianowicie <em>clickjackingu</em>.</p>

<p class="podcast-transcript-jingle">jingiel</p>

<h3>Clickjacking</h3>

<p>Clickjacking jest ciekawym rodzajem podstępu. Użytkownik na stronie widzi i klika w jakiś niewinnie wyglądający link,
    a przeglądarka zamiast tego wykonuje coś całkiem nieprzewidzianego, np. "lajkuje" z jego konta jakąś nieznaną mu
    stronę. Ten wariant sztuczki niektórzy nazywają nawet odrębnie "likejackingiem". Żeby działać na jakimś przykładzie,
    możemy rozpatrzeć właśnie ten scenariusz, bo przemawia do wyobraźni i faktycznie występuje w przyrodzie.</p>

<p>Podstęp wykorzystuje fakt, że HTML pozwala utworzyć na stronie poprzez tag <code>iframe</code> czyli inline frame,
    ramkę, i załadować w niej inną stronę. Stroną może być np. podstrona serwisu Facebook zawierająca przycisk "like"
    jakiegoś produktu czy posta. Ta strona w ramce iframe będzie przez przeglądarkę wczytana w kontekście użytkownika
    przeglądarki, tyle że nie w nowej zakładce, a właśnie w ramce wewnątrz strony. Problem pojawia się, kiedy ktoś
    sprawi, że ta ramka będzie przezroczysta i niewidoczna (np. stosując opacity "0" i wysoki z-index). Wtedy może ją
    ustawić tak, żeby skłonić użytkownika w kliknięcie przezroczystego przycisku "like" zupełnie nieświadomie że właśnie
    to zrobił.</p>

<p>Jako twórcy aplikacji webowych chcemy przede wszystkim zapobiec wstrzyknięciu kodu na stronę którą developujemy, aby
    chronić naszych użytkowników. Content-security policy pozwala na to poprzez zablokowanie ładowania na stronie ramek
    z innych domen niż te, których faktycznie potrzebujemy do działania i znacznie ograniczyć możliwość takiego ataku na
    użytkowników.</p>

<p class="podcast-transcript-jingle">jingiel</p>

<h2>Rozwiązanie/mitygacja: Content-Security-Policy</h2>

<p>Tym sposobem dotarliśmy do sekcji, w której będę mógł trochę szerzej przedstawić rozwiązanie, a może raczej mitygację
    dla wspomnianych problemów i kilku im pokrewnych. Jeśli nasza strona pozwala na wstrzykiwanie kodu, to już w tym
    tkwi problem i w jej kodzie będziemy go docelowo chcieli rozwiązać, bo prawdopodobnie nieprawidłowo używamy
    frameworka i gdzieś poszliśmy za bardzo na skróty. Mechanizm Content-Security Policy pozwoli nam za to zablokować
    takie częściowo udane próby nadużyć i jeśli się takie pojawią, to wskaże nam gdzie nastąpiła próba ataku na
    użytkowników strony, przez mechanizm raportowania o którym jeszcze powiem.</p>

<p>Content-Security-Policy to standard, wspierany dziś w dużym stopniu przez wszystkie nowoczesne przeglądarki,
    pozwalający zdefiniować autorom stron jakie zasoby mogą być ładowane przez przeglądarkę, a jakie powinny zostać
    zablokowane. Z założenia ma ograniczyć możliwość wykonania ataków Cross Site Scripting, Clickjacking i innego
    rodzaju ataków code-injection skierowanych w przeglądarki. W tej chwili, na początku 2018 roku, dobrze wspierane w
    przeglądarkach są wersje 1 i 2 standardu, trwają prace nad wersją trzecią, ale to co mamy teraz zdecydowanie
    wystarcza już do rozwiązania wielu problemów.</p>

<p>Jako developerzy możemy zdefiniować politykę bezpieczeństwa strony na dwa sposoby:</p>

<ul>
    <li>Pierwszym z nich jest wysyłanie stringa gdzie deklarujemy nasze preferencje w nagłówku HTTP o nazwie
        <code>Content-Security-Policy</code>.</li>
    <li>Drugą możliwością, wprowadzoną dla wygody w drugiej wersji standardu, jest przesyłanie tej wartości w meta-tagu
        strony. Ta forma może być w wielu sytuacjach wygodniejsza dla nas programistów i programistek, bo kiedy mamy tag
        będący częścią strony, to możemy go wersjonować razem z całym kodem np. w gicie, wiemy też że po wdrożeniu na
        inny serwer niż nasz lokalny na maszynie developerskiej, konfiguracja nadal trafi do przeglądarki użytkownika,
        niezależnie od tego czy serwer zostanie jakoś szczególnie skonfigurowany.</li>
</ul>

<p>Jeśli podczas wczytywania strony przeglądarka napotka taki nagłówek lub meta-tag, to zastosuje politykę do wszystkich
    zasobów z którymi spotka się podczas dalszego przetwarzania strony.</p>

<p>Nagłówek HTTP, który definiujemy opisuje oczekiwane od przeglądarki zachowanie przy pomocy <strong>dyrektyw</strong>
    i ich <strong>wartości</strong>.</p>

<p>Dyrektywa określa rodzaj zasobów, np. dyrektywa o nazwie <code>script-src</code> wskazuje na ustawienia dotyczące
    przetwarzania JavaScript. Wartość dyrektywy to lista źródeł, z których mogą był ładowane zasoby tego typu. Cały
    nagłówek Content-Security-Policy zawiera więc zestaw par "klucz-kolekcja wartości", które są złączone tworząc formę
    jednego długiego stringa. To w jaki sposób to już detal, wystarczy popatrzeć na przykłady i jest dość jasne jak
    takiego stringa skleić.</p>

<p>Przykładowo dla wspomnianego klucza <code>script-src</code> możemy zezwolić na ładowanie skryptów zewnętrznych z tej
    domeny z której pochodzi strona plus, powiedzmy, z domeny disqus.com jeśli korzystamy z systemu komentarzy Disqus,
    plus np. google-analytics.com. Jeśli w wartościach wypiszemy takie trzy domeny, to jedynie skrypty z tych domen będą
    wykonane przez przeglądarkę. Nie będą natomiast domyślnie wykonane skrypty z tagów <code>script</code> ani te w
    atrybutach takich jak onclick albo onmouseover, te musielibyśmy jawnie włączyć dodając do listy zaufanych źródeł
    specjalne wartości które reprezentują te formy kodu.</p>

<p>Dyrektyw jest obecnie, czyli w drugiej wersji standardu zaledwie kilkanaście i odpowiadają różnego rodzaju zasobom
    które możemy chcieć kontrolować. Przejdę przez większość z nich, ale nie po to żeby je ktoś próbował zapamiętywać bo
    to nie ma tu sensu, tylko żeby pokazać nad czym mniej-więcej mamy kontrolę dzięki Content-Security-Policy.</p>

<p>Nadrzędną dyrektywą jest <code>default-src</code>, która jest używana w przypadku kiedy nie zdefiniujemy
    którejkolwiek z pozostałych, czyli pozwala nam zdefiniować wartośc domyślną. Generalnie dobrze ustawić jej jakąś
    restrykcyjną wartość, np. zezwalającą jedynie na ładowanie zasobów z tej samej domeny i jedynie na treści z
    zewnętrznych plików.</p>


<p>Dyrektywy, które pozwalają w bardziej granularny sposób kontrolować konkretne rodzaje zasobów to m.in</p>

<ul>
    <li>wspomniany wcześniej <code>script-src</code> dotyczący skryptów,</li>
    <li><code>style-src</code> dotyczący styli CSS,</li>
    <li><code>object-src</code> określający dozwolone źródła dla obiektów takich jak Flash, czy przeglądarkowa Java,
        czyli załączanych przez tagi object, applet i embed. Generalnie jeśli nie używamy tego typu staroci w
        przeglądarce to najlepiej nie zezwalać przeglądarce na ładowanie tego typu obiektów w ramach naszej strony,</li>
    <li><code>img-src</code> określa dozwolone źródła obrazków,</li>
    <li><code>media-src</code> dotyczy zasobów audio i video. Np. ten podcast na moim blogu jest embedowany jako plik
        audio i podlega tym regułom,</li>
    <li><code>frame-ancestors</code> pozwala generalnie ograniczyć źródła dla ramek takich jak iframe i zmniejszyć
        szansę na udany clickjacking,</li>
    <li><code>form-action</code> ogranicza lokalizacje, do których przeglądarka może nas przekierować po submicie
        formularza,</li>
    <li><code>font-src</code> dotyczy oczywiście czcionek.</li>
    <li>Nazwy dyrektyw dotyczące żądań wysyłanych z poziomu JavaScriptu i przekierowań inicjowanych przez kod JavaScript
        trochę się zmieniały pomiędzy wersjami standardu, ale generalnie wszędzie powinna być wspierana dyrektywa
        <code>connect-src</code> pozwalająca je zdefiniować.</li>
</ul>

<p>Wymieniłem tu kilka dyrektyw, które są do siebie podobne i dotyczą różnych kategorii zasobów które przeglądarka może
    blokować lub nie. Na uwagę zasługują jeszcze w szczególności dwie nieco inne dyrektywy CSP.</p>

<p>Pierwsza z nich to <code>upgrade-insecure-requests</code>, która instruuje przeglądarkę żeby wszelkie napotkane
    odwołania do zasobów po HTTP zamieniała na żądania HTTPS. W złożonych aplikacjach taka zmiana po stronie kodu całej
    aplikacji może być bardzo trudna i ta dyrektywa może pozwolić na łagodną migrację takich stron na HTTPS.</p>

<p>Drugą z ciekawych dyrektyw jest <code>report-uri</code>, które prawdopodobnie w trzeciej wersji standardu zostanie
    przemianowane na <code>report-to</code>. Ta dyrektywa pozwala nam poprosić przeglądarkę o to, żeby w przypadku
    naruszenia polityki Content-Security-Policy wysłała informację o tym zdarzeniu pod wskazany adres URL.</p>

<p>Informacja o naruszeniu jest wysyłana jako JSON-owa struktura zawierającą precyzyjną informacje na temat tego jaki
    zasób został zablokowany, które miejsce w kodzie strony próbowało się do niego odwołać, która konkretnie dyrektywa
    została naruszona i tym podobne rzeczy. Mechanizmu można go użyć nie tylko po to, żeby odnotowywać próby ataku na
    stronę, ale też żeby szybko wykryć sytuacje gdzie jako developerzy nałożyliśmy zbyt mocne ograniczenia, albo
    zapomnieliśmy dodać jakąś domenę na białą listę.</p>

<p>Co lepsze, możemy również poprosić przeglądarkę o samo raportowanie naruszeń, bez blokowania zasobów. Pozwala to w
    pewnym sensie przetestować nasze Content-Security-Policy bezpośrednio na produkcji w ten sposób, że przez jakiś czas
    jedynie zbieramy dane i obserwujemy co się dzieje, i dopiero na tej podstawie po 2 tygodniach albo miesiącu
    rzeczywiście włączamy blokowanie. Realizuje się to przez zmianę nagłówka HTTP albo odpowiadającego mu klucza
    meta-tagu z Content-Security-Policy na Content-Security-Policy-Report-Only. Ta prosta zmiana powoduje zmianę
    działania z wymuszania polityki bezpieczeństwa na ów tryb obserwacji, w którym jedynie zbieramy raporty o
    naruszeniach dyrektyw.</p>

<p class="podcast-transcript-jingle">jingiel</p>

<h2>Gdzie znaleźć więcej informacji</h2>

<p>W tym miejscu chętnie wszedłbym jeszcze głębiej w szczegóły, ale podcast już teraz wydaje się trochę długi i nie wiem
    czy komukolwiek się go przesłuchać podczas jednego dojazdu do pracy ;) Zakończę więc na tym ogólnym obrazie i
    pozostawiam chętnym temat do zgłębienia. To jak zawsze najłatwiej zrobić biorąc jakiś swój weekendowy projekt i
    dodając do niego odpowiedni meta tag. W notatkach do tego odcinka zamieszczam link do kursu na Pluralsight o nazwie
    <em>Defeating Cross-site Scripting with Content Security Policy</em>
    <reference url="https://app.pluralsight.com/courses/defeating-cross-site-scripting-content-security-policy"
        title="Defeating Cross-site Scripting with Content Security Policy" />. Tam w 2.5 h temat jest przerobiony od
    deski do deski i jeśli ktoś potrzebuje szczegółów albo chce wizualnie zapoznać się z tym wszystkim o czym mówiłem,
    to kurs jest naprawdę bardzo przystępny.</p>

<p>Ten odcinek podcastu "Programowanie na śniadanie" jest pierwszym ściśle technicznym odcinkiem i każdy feedback na
    jego temat od Ciebie będzie dla mnie cenny. Jeśli jesteś w stanie doradzić mi jak to nagranie mogłem zrobić lepiej,
    to odezwij się na facebooku albo napisz komentarz na blogu lub maila i daj mi o tym znać. Jestem ciekawy tego czy
    treść dla Ciebie jako programisty była interesująca i ma szanse wnieść coś do Twojej pracy, czy może chętniej
    posłuchałbyś albo posłuchałabyś o czymś innym? Pytam szczególnie dlatego, że podcasty jakie znam to w
    przytłaczającej większości luźne rozmowy i sam takich często słucham. Tu natomiast sprawdzam, czy w formie audio
    można również dostarczyć trochę ściślejszej technicznej wiedzy i jestem ciekaw czy w Twoim odczuciu jest ona
    przyswajalna w podobnym stopniu jak ta z książek czy kursów video, czy jednak w formie audio łatwiej się zgubić.</p>

<p>Ten odcinek kończy również mój etap przygotowań do premiery podcastu i wraz z jego publikacją uruchomiłem listę
    mailingową oraz stronę na facebooku, gdzie będę informował o nowych odcinkach. Mocno zachęcam oczywiście do
    zapisania się, nie będzie spamu bo teraz jest mi już trudno znaleźć czas na odpisanie na maile które do mnie
    przychodzą, a co dopiero na rozsyłanie własnych ;) Na listę mailingowa możesz zapisać się na moim blogu
    zakasanerekawy.taurit.pl w zakładce <em>Podcast</em>.</p>

<p>Dziękuję Ci za to, że zostałeś lub zostałaś aż do tego miejsca. Życzę udanego dnia, bo przypuszczam że podcastów tego
    typu słuchasz tak jak ja z rana i być może dzień pracy dopiero przed Tobą. Także do usłyszenia w kolejnym odcinku!
</p>

<p class="podcast-transcript-jingle">outro</p>

        </div>
    </div>
</div>
<hr>

<!-- Footer -->
<footer id="page-footer">
    <div class="container">
        <div class="row">
                <div class="col-md-12 text-center">
                    <p class="copyright text-muted">
                        Copyright © 2020 Paweł Bulwan
                        <br />
                            <i class="fa fa-rss icon-rss"></i> <a href="/feed.rss">RSS</a>
                        |
                            <i class="fa fa-rss icon-rss"></i> <a href="/feed.atom">Atom</a>
                    </p>
                </div>
        </div>
</div>

</footer>

<script>
var toggleNav=function(){var n=document.getElementById("navbar-collapse").classList;n.contains("collapse")?n.remove("collapse"):n.add("collapse")},navbarButton=document.getElementById("navbar-button"),refListHeader,refListContent,refListButton,inTextReferences,i,inTextReference;if(navbarButton.addEventListener("click",toggleNav,!1),refListHeader=document.getElementById("reference-list"),refListContent=document.getElementById("reference-list-content"),refListHeader!==null&&refListContent!==null){refListContent.style.display="none";refListHeader.innerHTML="<span id='show-reference-list'>Rozwiń listę odniesień ▾<\/button>";function showReferenceList(){var n=document.getElementById("reference-list"),t=document.getElementById("reference-list-content");n.innerHTML="Lista odniesień";t.style.display="block"}for(refListButton=document.getElementById("show-reference-list"),refListButton.onclick=showReferenceList,inTextReferences=document.getElementsByClassName?document.getElementsByClassName("resource-reference"):document.querySelectorAll(".resource-reference"),i=0;i<inTextReferences.length;++i)inTextReference=inTextReferences[i],inTextReference.onclick=showReferenceList}(function(n,t,i,r,u,f,e){n.GoogleAnalyticsObject=u;n[u]=n[u]||function(){(n[u].q=n[u].q||[]).push(arguments)};n[u].l=1*new Date;f=t.createElement(i);e=t.getElementsByTagName(i)[0];f.async=1;f.src=r;e.parentNode.insertBefore(f,e)})(window,document,"script","https://www.google-analytics.com/analytics.js","ga");ga("create","UA-92769796-1","auto");ga("send","pageview");
</script>

<link href="/assets/css/fontello.min.css" rel="stylesheet" type="text/css">

</body>
</html>
<script>(function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s); js.id = id;
    js.src = 'https://connect.facebook.net/pl_PL/sdk.js#xfbml=1&version=v2.12&appId=1768845453415639&autoLogAppEvents=1';
    fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>